/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type Transaction = {
  txnRef?: string | undefined;
  senderAccount?: string | undefined;
  receiverAccount?: string | undefined;
  senderBank?: string | undefined;
  receiverBank?: string | undefined;
  amount?: number | undefined;
  currency?: string | undefined;
  timestamp?: Date | undefined;
  metadata?: { [k: string]: any } | undefined;
  status?: string | undefined;
  settled?: boolean | undefined;
};

/** @internal */
export const Transaction$inboundSchema: z.ZodMiniType<Transaction, unknown> = z
  .pipe(
    z.object({
      txn_ref: types.optional(types.string()),
      sender_account: types.optional(types.string()),
      receiver_account: types.optional(types.string()),
      sender_bank: types.optional(types.string()),
      receiver_bank: types.optional(types.string()),
      amount: types.optional(types.number()),
      currency: types.optional(types.string()),
      timestamp: types.optional(types.date()),
      metadata: types.optional(z.record(z.string(), z.any())),
      status: types.optional(types.string()),
      settled: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "txn_ref": "txnRef",
        "sender_account": "senderAccount",
        "receiver_account": "receiverAccount",
        "sender_bank": "senderBank",
        "receiver_bank": "receiverBank",
      });
    }),
  );
/** @internal */
export type Transaction$Outbound = {
  txn_ref?: string | undefined;
  sender_account?: string | undefined;
  receiver_account?: string | undefined;
  sender_bank?: string | undefined;
  receiver_bank?: string | undefined;
  amount?: number | undefined;
  currency?: string | undefined;
  timestamp?: string | undefined;
  metadata?: { [k: string]: any } | undefined;
  status?: string | undefined;
  settled?: boolean | undefined;
};

/** @internal */
export const Transaction$outboundSchema: z.ZodMiniType<
  Transaction$Outbound,
  Transaction
> = z.pipe(
  z.object({
    txnRef: z.optional(z.string()),
    senderAccount: z.optional(z.string()),
    receiverAccount: z.optional(z.string()),
    senderBank: z.optional(z.string()),
    receiverBank: z.optional(z.string()),
    amount: z.optional(z.number()),
    currency: z.optional(z.string()),
    timestamp: z.optional(z.pipe(z.date(), z.transform(v => v.toISOString()))),
    metadata: z.optional(z.record(z.string(), z.any())),
    status: z.optional(z.string()),
    settled: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      txnRef: "txn_ref",
      senderAccount: "sender_account",
      receiverAccount: "receiver_account",
      senderBank: "sender_bank",
      receiverBank: "receiver_bank",
    });
  }),
);

export function transactionToJSON(transaction: Transaction): string {
  return JSON.stringify(Transaction$outboundSchema.parse(transaction));
}
export function transactionFromJSON(
  jsonString: string,
): SafeParseResult<Transaction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transaction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transaction' from JSON`,
  );
}
